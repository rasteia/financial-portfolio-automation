"""
Strategy executor for managing strategy execution and signal processing.

This module provides the execution engine that runs strategies, processes
their signals, and manages their lifecycle.
"""

from typing import Dict, List, Optional, Any, Callable
import logging
from datetime import datetime, timezone
from threading import Lock
import asyncio
from concurrent.futures import ThreadPoolExecutor

from .base import Strategy, StrategySignal, SignalType
from .registry import StrategyRegistry
from ..models.core import Quote, PortfolioSnapshot
from ..models.config import StrategyConfig


logger = logging.getLogger(__name__)


class StrategyExecutor:
    """
    Executes trading strategies and processes their signals.
    
    This class manages the execution of multiple strategies, processes their
    generated signals, and provides hooks for signal handling.
    """
    
    def __init__(self, registry: Optional[StrategyRegistry] = None):
        """
        Initialize strategy executor.
        
        Args:
            registry: Strategy registry to use (uses global if None)
        """
        from .registry import get_global_registry
        
        self.registry = registry or get_global_registry()
        self._signal_handlers: List[Callable[[StrategySignal], None]] = []
        self._execution_lock = Lock()
        self._is_running = False
        self.logger = logging.getLogger(__name__)
        
        # Execution statistics
        self._execution_count = 0
        self._total_signals_generated = 0
        self._last_execution_time: Optional[datetime] = None
        self._execution_errors = 0
    
    def add_signal_handler(self, handler: Callable[[StrategySignal], None]) -> None:
        """
        Add a signal handler function.
        
        Args:
            handler: Function to handle generated signals
        """
        if not callable(handler):
            raise ValueError("Signal handler must be callable")
        
        self._signal_handlers.append(handler)
        self.logger.info(f"Added signal handler: {handler.__name__}")
    
    def remove_signal_handler(self, handler: Callable[[StrategySignal], None]) -> None:
        """
        Remove a signal handler function.
        
        Args:
            handler: Function to remove
        """
        if handler in self._signal_handlers:
            self._signal_handlers.remove(handler)
            self.logger.info(f"Removed signal handler: {handler.__name__}")
    
    def execute_strategy(
        self,
        strategy: Strategy,
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot,
        historical_data: Optional[Dict[str, List[Quote]]] = None
    ) -> List[StrategySignal]:
        """
        Execute a single strategy and return its signals.
        
        Args:
            strategy: Strategy to execute
            market_data: Current market data
            portfolio: Current portfolio snapshot
            historical_data: Historical market data
            
        Returns:
            List of generated signals
        """
        if not strategy.is_active:
            self.logger.debug(f"Skipping inactive strategy {strategy.strategy_id}")
            return []
        
        try:
            # Update strategy state
            strategy.update_state(market_data, portfolio)
            
            # Generate signals
            signals = strategy.generate_signals(market_data, portfolio, historical_data)
            
            # Validate and filter signals
            valid_signals = []
            for signal in signals:
                if strategy.validate_signal(signal):
                    valid_signals.append(signal)
                    strategy.state.increment_signals()
                else:
                    self.logger.warning(f"Invalid signal generated by {strategy.strategy_id}: {signal}")
            
            self.logger.debug(f"Strategy {strategy.strategy_id} generated {len(valid_signals)} valid signals")
            return valid_signals
            
        except Exception as e:
            self.logger.error(f"Error executing strategy {strategy.strategy_id}: {e}")
            self._execution_errors += 1
            return []
    
    def execute_all_strategies(
        self,
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot,
        historical_data: Optional[Dict[str, List[Quote]]] = None,
        parallel: bool = False
    ) -> Dict[str, List[StrategySignal]]:
        """
        Execute all active strategies and return their signals.
        
        Args:
            market_data: Current market data
            portfolio: Current portfolio snapshot
            historical_data: Historical market data
            parallel: Whether to execute strategies in parallel
            
        Returns:
            Dictionary mapping strategy IDs to their generated signals
        """
        with self._execution_lock:
            self._is_running = True
            self._execution_count += 1
            self._last_execution_time = datetime.now(timezone.utc)
            
            try:
                active_strategies = self.registry.list_strategies(active_only=True)
                
                if not active_strategies:
                    self.logger.debug("No active strategies to execute")
                    return {}
                
                self.logger.info(f"Executing {len(active_strategies)} active strategies")
                
                if parallel and len(active_strategies) > 1:
                    return self._execute_strategies_parallel(
                        active_strategies, market_data, portfolio, historical_data
                    )
                else:
                    return self._execute_strategies_sequential(
                        active_strategies, market_data, portfolio, historical_data
                    )
                    
            finally:
                self._is_running = False
    
    def _execute_strategies_sequential(
        self,
        strategies: List[Strategy],
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot,
        historical_data: Optional[Dict[str, List[Quote]]]
    ) -> Dict[str, List[StrategySignal]]:
        """Execute strategies sequentially."""
        results = {}
        
        for strategy in strategies:
            signals = self.execute_strategy(strategy, market_data, portfolio, historical_data)
            results[strategy.strategy_id] = signals
            
            # Process signals immediately
            for signal in signals:
                self._process_signal(signal)
        
        total_signals = sum(len(signals) for signals in results.values())
        self._total_signals_generated += total_signals
        self.logger.info(f"Generated {total_signals} total signals from {len(strategies)} strategies")
        
        return results
    
    def _execute_strategies_parallel(
        self,
        strategies: List[Strategy],
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot,
        historical_data: Optional[Dict[str, List[Quote]]]
    ) -> Dict[str, List[StrategySignal]]:
        """Execute strategies in parallel using thread pool."""
        results = {}
        
        with ThreadPoolExecutor(max_workers=min(len(strategies), 4)) as executor:
            # Submit all strategy executions
            future_to_strategy = {
                executor.submit(
                    self.execute_strategy, strategy, market_data, portfolio, historical_data
                ): strategy
                for strategy in strategies
            }
            
            # Collect results
            for future in future_to_strategy:
                strategy = future_to_strategy[future]
                try:
                    signals = future.result(timeout=30)  # 30 second timeout
                    results[strategy.strategy_id] = signals
                    
                    # Process signals
                    for signal in signals:
                        self._process_signal(signal)
                        
                except Exception as e:
                    self.logger.error(f"Strategy {strategy.strategy_id} execution failed: {e}")
                    results[strategy.strategy_id] = []
                    self._execution_errors += 1
        
        total_signals = sum(len(signals) for signals in results.values())
        self._total_signals_generated += total_signals
        self.logger.info(f"Generated {total_signals} total signals from {len(strategies)} strategies (parallel)")
        
        return results
    
    def _process_signal(self, signal: StrategySignal) -> None:
        """
        Process a generated signal by calling all registered handlers.
        
        Args:
            signal: Signal to process
        """
        for handler in self._signal_handlers:
            try:
                handler(signal)
            except Exception as e:
                self.logger.error(f"Signal handler {handler.__name__} failed: {e}")
    
    def execute_strategy_by_id(
        self,
        strategy_id: str,
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot,
        historical_data: Optional[Dict[str, List[Quote]]] = None
    ) -> List[StrategySignal]:
        """
        Execute a specific strategy by ID.
        
        Args:
            strategy_id: ID of strategy to execute
            market_data: Current market data
            portfolio: Current portfolio snapshot
            historical_data: Historical market data
            
        Returns:
            List of generated signals
            
        Raises:
            ValueError: If strategy not found
        """
        strategy = self.registry.get_strategy(strategy_id)
        if not strategy:
            raise ValueError(f"Strategy {strategy_id} not found")
        
        return self.execute_strategy(strategy, market_data, portfolio, historical_data)
    
    def execute_strategies_by_symbol(
        self,
        symbol: str,
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot,
        historical_data: Optional[Dict[str, List[Quote]]] = None
    ) -> Dict[str, List[StrategySignal]]:
        """
        Execute all strategies that trade a specific symbol.
        
        Args:
            symbol: Symbol to filter strategies by
            market_data: Current market data
            portfolio: Current portfolio snapshot
            historical_data: Historical market data
            
        Returns:
            Dictionary mapping strategy IDs to their generated signals
        """
        strategies = self.registry.get_strategies_by_symbol(symbol)
        active_strategies = [s for s in strategies if s.is_active]
        
        if not active_strategies:
            self.logger.debug(f"No active strategies found for symbol {symbol}")
            return {}
        
        return self._execute_strategies_sequential(
            active_strategies, market_data, portfolio, historical_data
        )
    
    def get_execution_stats(self) -> Dict[str, Any]:
        """
        Get execution statistics.
        
        Returns:
            Dictionary containing execution statistics
        """
        return {
            'execution_count': self._execution_count,
            'total_signals_generated': self._total_signals_generated,
            'execution_errors': self._execution_errors,
            'last_execution_time': self._last_execution_time.isoformat() if self._last_execution_time else None,
            'is_running': self._is_running,
            'signal_handlers_count': len(self._signal_handlers),
            'average_signals_per_execution': (
                self._total_signals_generated / self._execution_count 
                if self._execution_count > 0 else 0
            )
        }
    
    def reset_stats(self) -> None:
        """Reset execution statistics."""
        self._execution_count = 0
        self._total_signals_generated = 0
        self._last_execution_time = None
        self._execution_errors = 0
        self.logger.info("Execution statistics reset")
    
    def is_running(self) -> bool:
        """Check if executor is currently running."""
        return self._is_running
    
    def stop_execution(self) -> None:
        """Stop current execution (for parallel execution)."""
        # This is a simple flag-based approach
        # In a more sophisticated implementation, you might use asyncio.Event
        self._is_running = False
        self.logger.info("Execution stop requested")