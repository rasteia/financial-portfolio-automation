"""
Base strategy framework for the financial portfolio automation system.

This module provides the abstract base class and core interfaces for implementing
trading strategies with signal generation and state management.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Dict, Any, List, Optional, Union
import logging

from ..models.core import Quote, Position, PortfolioSnapshot
from ..models.config import StrategyConfig, RiskLimits


logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Trading signal type enumeration."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


@dataclass
class StrategySignal:
    """Represents a trading signal generated by a strategy."""
    
    symbol: str
    signal_type: SignalType
    strength: float  # Signal strength from 0.0 to 1.0
    price: Optional[Decimal] = None
    quantity: Optional[int] = None
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal data after initialization."""
        self.validate()
    
    def validate(self) -> None:
        """Validate signal data integrity."""
        if not self.symbol or not isinstance(self.symbol, str):
            raise ValueError("Symbol must be a non-empty string")
        
        if not isinstance(self.signal_type, SignalType):
            raise ValueError("Signal type must be a SignalType enum value")
        
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError("Signal strength must be between 0.0 and 1.0")
        
        if self.price is not None and self.price <= 0:
            raise ValueError("Price must be positive")
        
        if self.quantity is not None and self.quantity <= 0:
            raise ValueError("Quantity must be positive")
        
        if not isinstance(self.timestamp, datetime):
            raise ValueError("Timestamp must be a datetime object")
        
        if not isinstance(self.metadata, dict):
            raise ValueError("Metadata must be a dictionary")


@dataclass
class StrategyState:
    """Represents the internal state of a strategy."""
    
    strategy_id: str
    is_active: bool = True
    last_update: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    positions: Dict[str, Position] = field(default_factory=dict)
    signals_generated: int = 0
    trades_executed: int = 0
    total_pnl: Decimal = Decimal('0')
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def update_position(self, position: Position) -> None:
        """Update position in strategy state."""
        self.positions[position.symbol] = position
        self.last_update = datetime.now(timezone.utc)
    
    def remove_position(self, symbol: str) -> None:
        """Remove position from strategy state."""
        if symbol in self.positions:
            del self.positions[symbol]
            self.last_update = datetime.now(timezone.utc)
    
    def increment_signals(self) -> None:
        """Increment signals generated counter."""
        self.signals_generated += 1
        self.last_update = datetime.now(timezone.utc)
    
    def increment_trades(self) -> None:
        """Increment trades executed counter."""
        self.trades_executed += 1
        self.last_update = datetime.now(timezone.utc)
    
    def update_pnl(self, pnl_change: Decimal) -> None:
        """Update total PnL."""
        self.total_pnl += pnl_change
        self.last_update = datetime.now(timezone.utc)


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    This class defines the common interface that all strategies must implement,
    including signal generation, state management, and configuration handling.
    """
    
    def __init__(self, config: StrategyConfig):
        """
        Initialize strategy with configuration.
        
        Args:
            config: Strategy configuration containing parameters and risk limits
        """
        self.config = config
        self.state = StrategyState(strategy_id=config.strategy_id)
        self.logger = logging.getLogger(f"{__name__}.{config.strategy_id}")
        
        # Validate configuration
        config.validate()
        
        self.logger.info(f"Initialized strategy {config.strategy_id} of type {config.strategy_type}")
    
    @property
    def strategy_id(self) -> str:
        """Get strategy ID."""
        return self.config.strategy_id
    
    @property
    def strategy_type(self) -> str:
        """Get strategy type."""
        return self.config.strategy_type.value
    
    @property
    def symbols(self) -> List[str]:
        """Get list of symbols this strategy trades."""
        return self.config.symbols.copy()
    
    @property
    def risk_limits(self) -> RiskLimits:
        """Get risk limits for this strategy."""
        return self.config.risk_limits
    
    @property
    def is_active(self) -> bool:
        """Check if strategy is active."""
        return self.config.is_active and self.state.is_active
    
    def activate(self) -> None:
        """Activate the strategy."""
        self.state.is_active = True
        self.logger.info(f"Strategy {self.strategy_id} activated")
    
    def deactivate(self) -> None:
        """Deactivate the strategy."""
        self.state.is_active = False
        self.logger.info(f"Strategy {self.strategy_id} deactivated")
    
    @abstractmethod
    def generate_signals(
        self,
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot,
        historical_data: Optional[Dict[str, List[Quote]]] = None
    ) -> List[StrategySignal]:
        """
        Generate trading signals based on market data and portfolio state.
        
        Args:
            market_data: Current market quotes for relevant symbols
            portfolio: Current portfolio snapshot
            historical_data: Historical market data for analysis
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def update_state(
        self,
        market_data: Dict[str, Quote],
        portfolio: PortfolioSnapshot
    ) -> None:
        """
        Update internal strategy state based on current market conditions.
        
        Args:
            market_data: Current market quotes
            portfolio: Current portfolio snapshot
        """
        pass
    
    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate a generated signal against strategy constraints.
        
        Args:
            signal: Signal to validate
            
        Returns:
            True if signal is valid, False otherwise
        """
        try:
            # Basic signal validation
            signal.validate()
            
            # Check if symbol is in strategy's symbol list
            if signal.symbol not in self.symbols:
                self.logger.warning(f"Signal for {signal.symbol} not in strategy symbols")
                return False
            
            # Check signal strength threshold
            min_strength = self.config.parameters.get('min_signal_strength', 0.5)
            if signal.strength < min_strength:
                self.logger.debug(f"Signal strength {signal.strength} below threshold {min_strength}")
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"Signal validation failed: {e}")
            return False
    
    def calculate_position_size(
        self,
        signal: StrategySignal,
        portfolio_value: Decimal,
        current_price: Decimal
    ) -> int:
        """
        Calculate appropriate position size for a signal.
        
        Args:
            signal: Trading signal
            portfolio_value: Current portfolio value
            current_price: Current price of the security
            
        Returns:
            Position size in shares
        """
        # Get position sizing parameters
        max_position_value = self.risk_limits.calculate_max_position_value(portfolio_value)
        
        # Calculate base position size
        signal_strength_factor = signal.strength
        base_position_value = max_position_value * Decimal(str(signal_strength_factor))
        
        # Ensure minimum position value
        if base_position_value < self.risk_limits.min_position_value:
            base_position_value = self.risk_limits.min_position_value
        
        # Calculate shares
        shares = int(base_position_value / current_price)
        
        # Ensure we don't exceed maximum position size
        max_shares = int(self.risk_limits.max_position_size / current_price)
        shares = min(shares, max_shares)
        
        return max(1, shares)  # At least 1 share
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """
        Get strategy performance metrics.
        
        Returns:
            Dictionary containing performance metrics
        """
        return {
            'strategy_id': self.strategy_id,
            'strategy_type': self.strategy_type,
            'is_active': self.is_active,
            'signals_generated': self.state.signals_generated,
            'trades_executed': self.state.trades_executed,
            'total_pnl': float(self.state.total_pnl),
            'position_count': len(self.state.positions),
            'last_update': self.state.last_update.isoformat(),
            'symbols': self.symbols
        }
    
    def reset_state(self) -> None:
        """Reset strategy state to initial conditions."""
        self.state = StrategyState(strategy_id=self.strategy_id)
        self.logger.info(f"Strategy {self.strategy_id} state reset")
    
    def update_config(self, new_config: StrategyConfig) -> None:
        """
        Update strategy configuration.
        
        Args:
            new_config: New strategy configuration
        """
        if new_config.strategy_id != self.strategy_id:
            raise ValueError("Cannot change strategy ID")
        
        if new_config.strategy_type != self.config.strategy_type:
            raise ValueError("Cannot change strategy type")
        
        new_config.validate()
        self.config = new_config
        self.logger.info(f"Strategy {self.strategy_id} configuration updated")
    
    def __str__(self) -> str:
        """String representation of the strategy."""
        return f"Strategy(id={self.strategy_id}, type={self.strategy_type}, active={self.is_active})"
    
    def __repr__(self) -> str:
        """Detailed string representation of the strategy."""
        return (f"Strategy(id={self.strategy_id}, type={self.strategy_type}, "
                f"symbols={self.symbols}, active={self.is_active})")